% ============================================================================
% Глава 1: Въведение
% ============================================================================
\section{Въведение}

\subsection{Актуалност на проблема}

През последните две десетилетия уеб технологиите претърпяха драматична трансформация. От статични HTML страници, обслужвани от прости CGI скриптове, се премина към сложни интерактивни приложения, работещи в реално време. Съвременните уеб услуги трябва да обработват хиляди, а понякога и милиони едновременни връзки, като същевременно поддържат латентност от порядъка на милисекунди.

Традиционните подходи за изграждане на уеб сървъри се базират на модела ``една нишка на връзка'' (thread-per-connection). При този модел всяка входяща връзка се обслужва от отделна нишка, която блокира докато чака данни от клиента или от базата данни. Макар и концептуално прост, този подход се сблъсква със сериозни ограничения при мащабиране. Създаването на нишка консумира значителни системни ресурси -- типично около 1MB памет за стека. При хиляди едновременни връзки консумацията на памет става неприемлива. Освен това, контекстното превключване между нишките въвежда допълнителен overhead, който намалява общата производителност на системата.

Тези ограничения мотивираха разработването на асинхронни модели на изпълнение. При асинхронния подход малък брой нишки (обикновено равен на броя на CPU ядрата) обслужва множество връзки, като използва неблокиращи I/O операции и event loops. Когато една операция не може да завърши веднага, вместо да блокира нишката, тя регистрира callback функция, която ще бъде извикана при завършване на операцията. Междувременно нишката може да обслужва други заявки.

Езикът C++ остава предпочитан избор за системно програмиране и приложения с високи изисквания към производителността. Неговата способност да генерира оптимизиран машинен код, съчетана с богата стандартна библиотека и възможности за низкониво програмиране, го правят идеален за изграждане на високопроизводителни мрежови приложения.

С въвеждането на корутините в стандарта C++20 \cite{cpp20standard} се открива нова възможност за създаване на асинхронен код, който е едновременно ефективен и четим. Корутините са функции, които могат да спрат изпълнението си в определени точки и да го възобновят по-късно, без да блокират нишката. Това позволява писане на код, който изглежда синхронен и последователен, но всъщност се изпълнява асинхронно. По този начин се елиминира т.нар. ``callback hell'' -- проблемът с дълбоко вложени callback функции, характерен за традиционните асинхронни API-та.

\subsection{Цели и задачи}

Основната цел на настоящата дипломна работа е проектирането и реализацията на модерна C++ библиотека за създаване на уеб приложения, която да отговаря на съвременните изисквания за производителност, надеждност и удобство при разработка.

Библиотеката трябва да \textbf{опростява разработката} на уеб приложения чрез интуитивен API, базиран на C++20 корутини. Разработчиците трябва да могат да пишат асинхронен код със синтаксис, подобен на синхронния, без да се налага да управляват ръчно callbacks или promises.

Библиотеката трябва да \textbf{осигурява висока производителност} чрез неблокиращ I/O и ефективно управление на ресурсите. Целта е да се постигне производителност, сравнима с водещите C++ уеб библиотеки, като същевременно се запази простотата на API-то.

Библиотеката трябва да \textbf{поддържа множество протоколи}, включително HTTP/1.1, HTTP/2 и WebSocket. HTTP/2 е особено важен за съвременните уеб приложения, тъй като позволява мултиплексиране на заявки и ефективна компресия на хедъри. WebSocket е необходим за приложения, изискващи двупосочна комуникация в реално време.

Библиотеката трябва да \textbf{предоставя типова безопасност} при извличане на параметри от URL адреси. Вместо да връща параметрите като низове, които трябва да се конвертират ръчно, библиотеката трябва автоматично да извлича стойности от правилния тип, като грешките се откриват по време на компилация.

Библиотеката трябва да бъде \textbf{платформено независима}, работеща на Windows, Linux и macOS. За всяка платформа трябва да се използват оптимизираните native механизми за асинхронен I/O.

Библиотеката трябва да бъде \textbf{разширяема}, позволявайки лесно добавяне на нови протоколи и middleware компоненти. Архитектурата трябва да следва принципите на модулност и разделение на отговорностите.

За постигане на тези цели са поставени следните конкретни задачи:

Първата задача е \textbf{анализ на съществуващи C++ уеб библиотеки}. Необходимо е да се проучат популярните решения като Boost.Beast, Drogon, Crow и други, да се идентифицират техните предимства и недостатъци, и да се определи какви функционалности липсват на пазара.

Втората задача е \textbf{проектиране на модулна архитектура} с ясно разделение на отговорностите. Архитектурата трябва да позволява независимо развитие на отделните компоненти и лесно добавяне на нови функционалности.

Третата задача е \textbf{реализация на корутинна инфраструктура}. Необходимо е да се създаде типът \texttt{Task<T>}, който да служи като основа за асинхронните операции в библиотеката.

Четвъртата задача е \textbf{имплементация на DFA-базиран маршрутизатор} с O(N) сложност, базиран на алгоритъма, описан в „Matching Text from Start to Finish Against Multiple Regular Expressions" \cite{stankov2024regex}. Този алгоритъм позволява ефективно съпоставяне на URL адреси с множество шаблони.

Петата задача е \textbf{разработка на платформено-специфични I/O бекенди} за IOCP (Windows), io\_uring (Linux) и kqueue (macOS). Всеки бекенд трябва да използва оптимално native механизмите на съответната операционна система.

Шестата задача е \textbf{интеграция на HTTP/2} с ALPN негоциация и HPACK компресия на хедъри. HTTP/2 трябва да работи безпроблемно заедно с HTTP/1.1, като протоколът се избира автоматично при TLS handshake.

Седмата задача е \textbf{реализация на WebSocket протокол} за двупосочна комуникация. WebSocket трябва да поддържа както текстови, така и бинарни съобщения.

Осмата задача е \textbf{тестване и benchmark анализ} на производителността. Необходимо е да се създадат unit тестове за всички компоненти и да се измери производителността в сравнение с други библиотеки.

\subsection{Обхват и ограничения}

При проектирането на всяка софтуерна система е важно ясно да се дефинира какво влиза в обхвата на разработката и какво остава извън него. Това позволява фокусиране на усилията върху ключовите функционалности и избягване на т.нар. ``scope creep'' -- неконтролираното разширяване на изискванията.

Библиотеката Coroute е проектирана като \textit{library}, а не като самостоятелен сървър или framework. Това е съзнателно архитектурно решение, което дава на разработчиците максимална гъвкавост. Библиотеката предоставя градивни блокове за създаване на уеб приложения, но оставя контрола върху конфигурацията, разгръщането и интеграцията с други системи изцяло на разработчика.

В обхвата на настоящата разработка влизат следните функционалности:

Поддръжката на \textbf{HTTP/1.1 и HTTP/2 протоколи} е основна функционалност на библиотеката. HTTP/1.1 е все още широко използван и трябва да се поддържа за съвместимост. HTTP/2 предоставя значителни подобрения в производителността и е необходим за съвременни приложения.

\textbf{WebSocket протоколът} позволява двупосочна комуникация между клиент и сървър. Това е необходимо за приложения като чат системи, игри в реално време, колаборативни редактори и dashboard-и с live updates.

\textbf{TLS криптирането} е задължително за съвременните уеб приложения. Библиотеката трябва да поддържа TLS 1.2 и TLS 1.3, включително ALPN негоциация за избор на HTTP протокол.

\textbf{Статичното обслужване на файлове} е често срещано изискване. Библиотеката трябва да поддържа ефективно обслужване на статични ресурси като CSS, JavaScript и изображения, включително zero-copy трансфер където е възможно.

\textbf{Middleware системата} позволява добавяне на cross-cutting concerns като логване, автентикация, компресия и rate limiting. Middleware компонентите трябва да могат да се композират в произволен ред.

\textbf{Маршрутизирането с параметри} позволява дефиниране на динамични URL шаблони като \texttt{/users/\{id\}}. Параметрите трябва да се извличат автоматично и да се валидират по тип.

Извън обхвата на настоящата разработка остават следните функционалности:

\textbf{HTTP/3 (QUIC)} е най-новата версия на HTTP протокола, базирана на UDP вместо TCP. Въпреки че HTTP/3 предоставя допълнителни подобрения в производителността, неговата имплементация е значително по-сложна и е планирана за бъдещи версии на библиотеката.

\textbf{Вградена база данни или ORM} не е част от обхвата. Библиотеката се фокусира върху мрежовия слой и оставя избора на database решение на разработчика. Това позволява интеграция с произволна база данни -- SQL, NoSQL или in-memory.

\textbf{Шаблонна система за генериране на HTML} също не е включена. Разработчиците могат да използват външни библиотеки като inja, mustache или да генерират HTML програмно.

\textbf{Автоматичното мащабиране и load balancing} са функционалности на инфраструктурно ниво, които обикновено се реализират чрез външни инструменти като Kubernetes, nginx или HAProxy.

\subsection{Структура на дипломната работа}

Дипломната работа е организирана в следните глави:

\textbf{Глава 2} представя преглед на съществуващите C++ уеб библиотеки, техните характеристики и сравнителен анализ.

\textbf{Глава 3} въвежда теоретичната основа -- HTTP протоколи, WebSocket, TLS, C++20 корутини, асинхронен I/O и DFA-базирано маршрутизиране.

\textbf{Глава 4} описва архитектурата на Coroute -- модулна структура, жизнен цикъл на заявките, корутинен модел и middleware верига.

\textbf{Глава 5} разглежда реализацията на поддържаните протоколи -- HTTP/1.1, HTTP/2 и WebSocket.

\textbf{Глава 6} представя системата за типово-безопасно извличане на параметри от URL адреси.

\textbf{Глава 7} демонстрира примерно приложение, изградено с библиотеката.

\textbf{Глава 8} съдържа резултатите от тестването и анализ на производителността.

\textbf{Заключението} обобщава постигнатите резултати и очертава насоки за бъдещо развитие.
