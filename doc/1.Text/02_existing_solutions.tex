% ============================================================================
% Глава 2: Преглед на съществуващи решения
% ============================================================================
\section{Преглед на съществуващи решения}

Анализът на съществуващите решения е критична стъпка в процеса на проектиране на нова софтуерна система. Той позволява да се идентифицират утвърдени архитектурни модели, да се избегнат известни проблеми и да се определят области, в които новото решение може да предостави добавена стойност. В контекста на C++ уеб библиотеки, този анализ е особено важен поради разнообразието от подходи --- от низкониво мрежово програмиране до високониво абстракции, подобни на тези в интерпретираните езици.

Настоящата глава представя систематичен преглед на пет водещи C++ библиотеки за уеб разработка: Boost.Beast, Drogon, Crow, Oat++ и Pistache. За всяка библиотека се анализират архитектурните решения, моделът на конкурентност, API дизайнът и документираната производителност. Анализът завършва със сравнителна таблица и обосновка на мотивацията за разработване на Coroute.

\subsection{Boost.Beast}

Boost.Beast \cite{boost_beast} е част от утвърдената колекция Boost библиотеки и представлява една от най-зрелите имплементации на HTTP и WebSocket протоколите за C++. Библиотеката е изградена върху Boost.Asio, което й осигурява солидна основа за асинхронни мрежови операции.

Философията на Boost.Beast е да предостави ниско ниво на абстракция, давайки на разработчика пълен контрол върху всеки аспект на HTTP комуникацията. Това означава, че библиотеката не налага конкретна архитектура или модел на използване, а вместо това предоставя градивни блокове, от които разработчикът може да изгради своето решение.

Едно от основните предимства на Boost.Beast е нейната интеграция с Boost екосистемата. Разработчиците, които вече използват други Boost библиотеки, могат лесно да добавят HTTP функционалност към своите проекти. Документацията е изчерпателна и включва множество примери за различни сценарии на използване. Активната общност осигурява бърза помощ при възникнали проблеми.

Въпреки тези предимства, Boost.Beast има и съществени недостатъци. Ниското ниво на абстракция означава, че дори прости задачи изискват значително количество код. Липсата на вградено маршрутизиране принуждава разработчиците да имплементират собствена логика за насочване на заявките. Няма middleware система, което затруднява добавянето на cross-cutting concerns като логване, автентикация или компресия. Кривата на обучение е стръмна, особено за разработчици без опит с Boost.Asio.

\subsection{Drogon}

Drogon \cite{drogon} се е утвърдил като един от най-бързите C++ уеб библиотеки, редовно заемащ водещи позиции в TechEmpower Web Framework Benchmarks \cite{techempower}. Библиотеката е разработен с фокус върху производителността и предоставя пълен набор от функционалности за изграждане на съвременни уеб приложения.

Архитектурата на Drogon е базирана на неблокиращ I/O модел, използващ event loop за обработка на множество едновременни връзки. Библиотеката поддържа HTTP/1.1, HTTP/2 и WebSocket протоколи, което го прави подходящ за широк спектър от приложения. Вградената ORM система улеснява работата с бази данни, като поддържа PostgreSQL, MySQL и SQLite.

Една от силните страни на Drogon е неговата middleware система, която позволява добавяне на филтри за обработка на заявките. Библиотеката предоставя и инструменти за автоматично генериране на контролери от дефиниции, което ускорява разработката. Документацията е добра, макар и предимно на английски и китайски език.

Въпреки впечатляващата производителност, Drogon има някои недостатъци. Асинхронният модел е базиран на callbacks, което може да доведе до т.нар. ``callback hell'' при сложна логика. Въпреки че последните версии добавят частична поддръжка на C++20 корутини, тя не е пълноценна и не покрива всички аспекти на библиотеката. Конфигурацията може да бъде сложна за начинаещи, а размерът на библиотеката е значителен, което увеличава времето за компилация.

\subsection{Crow}

Crow \cite{crow} е микробиблиотека, вдъхновен от популярния Python библиотека Flask. Основната цел на Crow е да предостави минималистичен и интуитивен API, който позволява бързо създаване на уеб приложения с минимално количество код.

Една от най-привлекателните характеристики на Crow е неговата простота. Библиотеката е реализиран като header-only библиотека, което означава, че интеграцията в проект се свежда до включване на един header файл. Маршрутизирането се извършва чрез lambda функции, което прави кода четим и лесен за разбиране. За разработчици, идващи от Python или JavaScript екосистемите, синтаксисът на Crow ще изглежда познат и интуитивен.

Crow е особено подходящ за малки проекти, прототипи и вътрешни инструменти, където простотата е по-важна от производителността. Библиотеката поддържа WebSocket комуникация и предоставя базова middleware функционалност.

Въпреки своята елегантност, Crow има съществени ограничения. Липсата на HTTP/2 поддръжка го прави неподходящ за съвременни production приложения, които изискват мултиплексиране и ефективна компресия на хедъри. Синхронният модел по подразбиране означава, че при високо натоварване производителността страда значително. Библиотеката не предоставя вградени инструменти за работа с бази данни, сесии или автентикация, което налага използването на допълнителни библиотеки.

\subsection{Oat++}

Oat++ \cite{oatpp} представлява модерен подход към C++ уеб разработката, поставяйки силен акцент върху типовата безопасност и автоматизацията. Библиотеката е проектиран с идеята, че API документацията трябва да се генерира автоматично от кода, а не да се поддържа ръчно.

Централна концепция в Oat++ е системата от Data Transfer Objects (DTO). Разработчиците дефинират структурите на данните чрез специални макроси, които позволяват автоматична сериализация и десериализация към JSON, както и генериране на OpenAPI/Swagger документация. Това елиминира честите грешки при ръчно писане на документация и гарантира, че тя винаги е синхронизирана с кода.

Библиотеката предоставя както синхронен, така и асинхронен API, давайки на разработчиците гъвкавост при избора на модел на изпълнение. Вградената система за валидация на входни данни допълнително подобрява надеждността на приложенията.

Основният недостатък на Oat++ е неговата собствена система от типове. Вместо да използва стандартни C++ типове, библиотеката изисква използването на специални wrapper класове, което може да бъде объркващо за начинаещи. Кривата на обучение е по-стръмна в сравнение с по-простите библиотеки. Липсата на HTTP/2 поддръжка е съществен пропуск за приложения, изискващи висока производителност при множество едновременни заявки.

\subsection{Pistache}

Pistache \cite{pistache} е библиотека, специализиран в създаването на RESTful API услуги. Проектиран е с фокус върху елегантността на кода и лесната употреба, следвайки принципите на модерния C++ дизайн.

API-то на Pistache е чисто и изразително, позволявайки дефиниране на endpoints с минимално количество boilerplate код. Библиотеката използва асинхронен модел на изпълнение, базиран на Linux epoll, което осигурява добра производителност при обработка на множество едновременни връзки. Вградената поддръжка за HTTP методи, статус кодове и content negotiation улеснява изграждането на стандартни REST API-та.

Pistache предоставя и допълнителни функционалности като rate limiting, timeout management и graceful shutdown, които са важни за production deployments. Документацията е ясна и включва примери за често срещани сценарии.

Най-съществените ограничения на Pistache са свързани с платформената поддръжка и функционалността. Библиотеката работи само на Linux, което го прави неподходящ за проекти, изискващи cross-platform съвместимост. Липсата на HTTP/2 и WebSocket поддръжка ограничава приложимостта му в съвременни уеб приложения. Активността на проекта е намаляла през последните години, което поражда въпроси относно дългосрочната поддръжка и развитие.

\subsection{Сравнителен анализ}

След детайлния преглед на всеки библиотека, е полезно да направим систематично сравнение по ключови характеристики. Таблица \ref{tab:comparison} обобщава поддръжката на различни функционалности от всеки от разгледаните библиотеки, включително Coroute.

\begin{table}[H]
\centering
\caption{Сравнение на C++ уеб библиотеки по ключови характеристики}
\label{tab:comparison}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\textbf{Характеристика} & \textbf{Beast} & \textbf{Drogon} & \textbf{Crow} & \textbf{Oat++} & \textbf{Pistache} & \textbf{Coroute} \\
\hline
HTTP/1.1 & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
HTTP/2 & -- & \checkmark & -- & -- & -- & \checkmark \\
WebSocket & \checkmark & \checkmark & \checkmark & \checkmark & -- & \checkmark \\
C++20 корутини & -- & частично & -- & -- & -- & \checkmark \\
Middleware & -- & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
Типово маршрут. & -- & -- & -- & \checkmark & -- & \checkmark \\
Cross-platform & \checkmark & \checkmark & \checkmark & \checkmark & -- & \checkmark \\
\hline
\end{tabular}
\end{table}

От таблицата се вижда, че всеки библиотека има своите силни страни, но нито един не предоставя пълния набор от желани функционалности. Boost.Beast е мощен, но ниско ниво. Drogon е бърз, но callback-базиран. Crow е прост, но ограничен. Oat++ е типово-безопасен, но без HTTP/2. Pistache е елегантен, но само за Linux.

\subsection{Мотивация за Coroute}

Анализът на съществуващите решения разкрива съществена празнина на пазара. Няма C++ библиотека, който да комбинира всички следни характеристики в едно цялостно решение:

Първо, \textbf{пълноценна поддръжка на C++20 корутини}. Корутините са революционна функционалност, която позволява писане на асинхронен код със синтаксис, подобен на синхронния. Въпреки че C++20 е наличен от 2020 година, повечето библиотеки все още използват callback-базирани модели или предоставят само частична поддръжка на корутини.

Второ, \textbf{HTTP/2 с ALPN негоциация}. HTTP/2 е стандарт от 2015 година и предоставя значителни подобрения в производителността чрез мултиплексиране на потоци и компресия на хедъри. Въпреки това, много C++ библиотеки все още не го поддържат или изискват сложна конфигурация.

Трето, \textbf{типово-безопасно маршрутизиране с compile-time проверки}. Традиционните библиотеки извличат параметри от URL като низове, оставяйки валидацията на runtime. Използването на C++ шаблони позволява проверка на типовете по време на компилация, елиминирайки цял клас грешки.

Четвърто, \textbf{DFA-базирано маршрутизиране с O(N) сложност}. Повечето библиотеки използват последователно съпоставяне на маршрути, което води до O(N × M) сложност. Алгоритъмът, описан в „Matching Text from Start to Finish Against Multiple Regular Expressions" \cite{stankov2024regex}, позволява съпоставяне с линейна сложност спрямо дължината на URL-а, независимо от броя на маршрутите.

Пето, \textbf{платформена независимост с оптимизирани I/O бекенди}. Различните операционни системи предоставят различни механизми за асинхронен I/O -- IOCP на Windows, io\_uring на Linux, kqueue на macOS. Оптималната производителност изисква използване на native механизми за всяка платформа.

Coroute е създаден с амбицията да запълни тази ниша. Библиотеката комбинира всички изброени характеристики в едно цялостно, модерно и ефективно решение за C++ уеб разработка. В следващите глави ще разгледаме детайлно архитектурата и имплементацията на всяка от тези функционалности.
